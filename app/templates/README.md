1. Everything in a module is organized by functionality, not function. This means that views and templates that serve the same purpose (for example: Navigation) are placed inside the same folder. They are not split into separate folders for views and templates. This is done so that working on a piece of functionality, as developers often do, is restrained to a single module in the app.
2. Where possible, configuration should be abstracted into JSON files. For content, this pulls out a huge huge huge chunk of non-logical stuff from your programs and allows you to keep content (whose contents the app should not care about) and the logic (the actual engine of the app) separate. For configuration, this allows dynamic module loading, environment specific configurations and dynamic routing to exist, as well as dynamic navigation generation. In the future, permission based delivery and administrative duties (such as modifying the content) will be much easier to implement.
3. Simplified structure maintenance; The whole goal of the framework is that it should be abstracted enough to the App level that future development should only require minor data file changes and work within module folders. This significantly lowers the experience level needed to maintain and enhance the application in the future.
4. Because configuration is abstracted from application logic, implementing role based loading and permissions in the future will also be much easier, and less messy, than it otherwise would have been. A single global module can handle loading of modules based on permission rather than cluttering the main app and modules with logic.
5. Separation of concerns. No one module should be able to hinder the operation of the app as a whole. There should be no inter-module dependencies. And all communication should be to an App level module (which must work for the app to run) or via events that the servicing module must bind to.